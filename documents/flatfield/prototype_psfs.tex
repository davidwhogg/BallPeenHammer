\documentclass[12pt,preprint,pdftex]{aastex}

\newcommand{\documentname}{\textsl{Note}}
\newcommand{\equationname}{equation}
\newcommand{\foreign}[1]{\textsl{#1}}
\newcommand{\etal}{\foreign{et\,al.}}
\newcommand{\project}[1]{\textsl{#1}}
\newcommand{\given}{\,|\,}
\newcommand{\setofall}[1]{\left\{{#1}\right\}}
\newcommand{\dd}{\mathrm{d}}
\newcommand{\vc}[1]{\mathbf{#1}}
\newcommand{\transpose}[1]{{#1}^{\!{\mathsf{T}}}}

\begin{document}\sloppy\sloppypar

\noindent{\ttfamily This document is a draft.  It is Copyright 2013
  David W. Hogg, Ross Fadely, Rob Fergus, and others.  It is not ready
  for distribution.}


\section{Calibration using prototype psfs}

\subsection{Model}

The goal of the proposed algorithm is to infer a model for the flat field of a detector (here 
WFC3 IR channel), using a carefully selected set of patches around observed sources 
which are very likely stars.  The core idea is that (ignoring uncertainties in the bias) the 
data are generated as:

\begin{eqnarray}
\vc{d}_j = b_j \vc{p}_j \vc{f}_j
\label{eq:basic}
\end{eqnarray}

\noindent where $\vc{d}_j$ is a patch of pixels for an observed source with shape 
$(m \times n)$ with $m, n$ odd and $\vc{d}_j$ centered on the brightest pixel for the 
observation.  $b_j$ is the brightness or total flux, $\vc{p}_j$ is the PSF model, and 
$\vc{f}_j$ is the patch of the flat field model for patch $j$.  In general, we also will 
consider an additive background model to Equation \ref{eq:basic} (see below).  

For this model to work, we must have a PSF model that is good enough to deliver our 
desired precision on the flat field calibration.  Here, we proposed to simultaneously 
learn a set of `prototype' PSF models which may be combined to obtain a model for any 
individual PSF $\vc{p}_j$.  These prototype PSFs are distributed around the detector 
in a uniform square grid with a total number $N_r$ used.  Each prototype 
PSF consists of a patch of pixel values of shape $(m \times n)$, whose values will be 
learned during the inference process.

To generate a PSF model for an observation $j$, a weighted combination of prototypes 
is constructed.  For a star centroid has true location $\vc{x}_j$, the four 
prototypes which surround $\vc{x}_j$ are chosen.  The model is then constructed by 
shifting the model pixel grid appropriately and adding the weighted prototype 
$w_k \vc{r}_k$, where $\vc{r}_k$ is the prototype PSF at position $k$ and $w_k$ is 
determined by the geometric location of the star centroid relative to the four prototypes.  
The values of $w_k$ for the $N_r - 4$ remaining prototypes is set to zero.
Figure \ref{fig:psf_gen} shows some examples of PSFs generated from prototypes.  Note 
that for pixels on the edge of the detector we simply mirror prototypes to the appropriate 
location outside the detector.

Our model for patch $\vc{m}_j$ is therefore specified as:

\begin{eqnarray}
\vc{m}_j &=& \vc{u}_j * \vc{f}_j \\
\vc{u}_j &=& \sum_k b_j w_{kj} (\vc{r_k} \otimes \vc{\delta}_k)
\label{eq:model}
\end{eqnarray}

\noindent where $\vc{u}_j$ is the unweighted model (before applying the flat) and 
$\vc{\delta}_k$ is the shift operator which is applied to the prototype.

\subsection{Optimization}

With this model, it is straightforward to right down a cost function as the sum of squared 
errors:

\begin{eqnarray}
C &=& \sum_j \epsilon_j^2 \\
    &=& \sum_j \sum_i (\vc{d}_{ij} - \vc{u}_{ij} \vc{f}_{ij})^2
\quad .
\label{eq:cost}
\end{eqnarray}

\noindent The scalar $\epsilon_j$ is the sum over the errors in each of the $i$ pixels in the 
$j$th patch.  The 
parameters we wish to optimize are the $N_r$ prototypes (each of which has $(m \times n)$ 
varying pixel values) and the pixel values of the flat field ($1014 \times 1014$ for WFC3).

For efficient optimization, it is helpful to compute gradients with respect to the parameters.  
The gradient of the cost with respect to the prototypes $\vc{r}_k$ is:

\begin{eqnarray}
\frac{dC}{d\vc{r}_k} &=& - \sum_j 2 w_{kj} b_j \transpose{\vc{\delta}_{kj}} \otimes (\vc{f}_j * \vc{\epsilon}_j)
\quad .
\label{eq:pk_grad}
\end{eqnarray}

\noindent while optimizing for the large number of flat field pixels seems daunting, we can 
fortunately write down an analytic update for the pixel values.  Imagine now that the flat field 
is represented as a huge diagonal matrix $\vc{F}$, and that the patches $\vc{d}_j, \vc{u}_j$ 
are represented as sparse vectors with length equal to the total number of pixels and zeros 
everywhere except for the pixels which the patch $j$ touches.  Then, 

\begin{eqnarray}
C &=& \sum_j (d_j - F u_j)^2 \\
\frac{dC}{d\vc{F}} &=& \sum_j \transpose{\vc{u}_j} \vc{d}_j - \transpose{\vc{u}_j} \vc{F} \vc{u}_j
\quad .
\label{eq:flat_deriv}
\end{eqnarray}

\noindent Setting $\frac{dC}{d\vc{F}} = 0$, the optimal flat is simply 
$\frac{\sum_j \vc{d}_j}{\sum_j \vc{u}_j}$.  Similar in practice to Expectation-Maximization 
optimization.  The prototype PSFs are solved for using LBFGS, who's cost function call consists 
of computing the expected prototypes and modifying the flat to that which maximizes the 
likelihood of the data.  Potentially, there is another set of parameters in the $b_j$ values.  
Here, we restrict the $b_j$ to be the sum of the data.  In principle we could also fit for the 
$b_j$ values, but there is a degeneracy between the prototype amplitude and $b_j$.  By 
forcing $b_j$ to be the sum of the pixel values this degeneracy is broken, and the prototype 
PSFs will naturally take the scale at which they sum to one.

\end{document}

